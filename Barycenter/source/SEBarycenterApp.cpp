#include "SEBarycenterApp.hpp"
#include "SEBarycenterAppGUI.hpp"
#include "SAMSON.hpp"
#include <fstream>
#include <QProcess>

SEBarycenterApp::SEBarycenterApp() {

	setGUI(new SEBarycenterAppGUI(this));
	getGUI()->loadDefaultSettings();

}

SEBarycenterApp::~SEBarycenterApp() {

	getGUI()->saveDefaultSettings();
	delete getGUI();

}

SEBarycenterAppGUI* SEBarycenterApp::getGUI() const { return static_cast<SEBarycenterAppGUI*>(SBDApp::getGUI()); }

std::string SEBarycenterApp::compute() {

    // find all selected atoms in the active document

    SBNodeIndexer atomIndexer;
    SAMSON::getActiveDocument()->getNodes(atomIndexer,
        SBNode::IsType(SBNode::Atom) && SBNode::IsSelected());

    // set the temporary files in the SAMSON's scratch folder

    const std::string scratchPath = SAMSON::getScratchPath();
    const std::string inputFilePath = scratchPath + "/tmp-barycenter-input.txt";
    const std::string outputFilePath = scratchPath + "/tmp-barycenter-output.txt";

    // generate the input file for the executable

    std::ofstream input(inputFilePath);
    input << atomIndexer.size() << std::endl;

    SB_FOR(SBNode * node, atomIndexer) {

        SBAtom* atom = static_cast<SBAtom*>(node);
        SBPosition3 position = atom->getPosition();

        input <<
            SBQuantity::angstrom(position.v[0]).getValue() << " " <<
            SBQuantity::angstrom(position.v[1]).getValue() << " " <<
            SBQuantity::angstrom(position.v[2]).getValue() << std::endl;

    }

    // execute the program and wait until it finishes
    // Note: the path to the executable corresponds to where it was copied in CMakeLists.txt

    QString program = QString::fromStdString(SB_ELEMENT_PATH + "/Resource/barycenter/barycenter");
#if SB_WINDOWS
        program = program + ".exe";
#endif

    QStringList arguments{
        QString::fromStdString(inputFilePath),
        QString::fromStdString(outputFilePath)
    };

    QProcess* process = new QProcess();
    process->setWorkingDirectory(QString::fromStdString(scratchPath));
    process->start(program, arguments);
    // wait until the process is finished or until time out at 60 seconds
    process->waitForFinished(60000);
    delete process;

    // read the output generated by the external executable

    std::ifstream output(outputFilePath);
    std::string result;
    std::getline(output, result);

    // delete the temporary files

    QFile(QString::fromStdString(inputFilePath)).remove();
    QFile(QString::fromStdString(outputFilePath)).remove();

    return result;

}
